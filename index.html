<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SNAKE.EXE</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=VT323&display=swap');

  :root {
    --green: #00ff41;
    --dim-green: #003b10;
    --mid-green: #00aa2c;
    --bg: #020d04;
    --grid: 20;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--green);
    font-family: 'Share Tech Mono', monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    overflow: hidden;
    position: relative;
  }

  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0,255,65,0.03) 2px,
      rgba(0,255,65,0.03) 4px
    );
    pointer-events: none;
    z-index: 100;
  }

  body::after {
    content: '';
    position: fixed;
    inset: 0;
    background: radial-gradient(ellipse at center, transparent 60%, rgba(0,0,0,0.8) 100%);
    pointer-events: none;
    z-index: 101;
  }

  .crt-flicker {
    animation: flicker 8s infinite;
  }

  @keyframes flicker {
    0%, 95%, 100% { opacity: 1; }
    96% { opacity: 0.85; }
    97% { opacity: 1; }
    98% { opacity: 0.9; }
  }

  h1 {
    font-family: 'VT323', monospace;
    font-size: 4rem;
    letter-spacing: 0.3em;
    text-shadow: 0 0 20px var(--green), 0 0 40px var(--green);
    margin-bottom: 4px;
    animation: pulse 2s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { text-shadow: 0 0 20px var(--green), 0 0 40px var(--green); }
    50% { text-shadow: 0 0 30px var(--green), 0 0 60px var(--green), 0 0 80px var(--green); }
  }

  .stats-bar {
    display: flex;
    gap: 3rem;
    margin-bottom: 12px;
    font-size: 0.9rem;
    letter-spacing: 0.15em;
    color: var(--mid-green);
  }

  .stats-bar span { color: var(--green); }

  .canvas-wrap {
    position: relative;
    border: 2px solid var(--mid-green);
    box-shadow: 0 0 30px rgba(0,255,65,0.3), inset 0 0 30px rgba(0,255,65,0.05);
  }

  canvas {
    display: block;
    image-rendering: pixelated;
  }

  .overlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(2, 13, 4, 0.88);
    font-family: 'VT323', monospace;
  }

  .overlay h2 {
    font-size: 3.5rem;
    letter-spacing: 0.2em;
    text-shadow: 0 0 20px var(--green);
    margin-bottom: 1rem;
  }

  .overlay p {
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.85rem;
    color: var(--mid-green);
    letter-spacing: 0.1em;
    margin-bottom: 0.4rem;
  }

  .blink {
    animation: blink 1s step-end infinite;
  }

  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
  }

  .start-hint {
    margin-top: 1.5rem;
    font-size: 1.4rem;
    letter-spacing: 0.2em;
    color: var(--green);
  }

  .footer {
    margin-top: 10px;
    font-size: 0.75rem;
    color: var(--dim-green);
    letter-spacing: 0.15em;
  }

  .high-score-display {
    font-size: 1.2rem;
    color: var(--mid-green);
    margin-top: 0.5rem;
    letter-spacing: 0.15em;
  }
</style>
</head>
<body class="crt-flicker">

<h1>SNAKE.EXE</h1>
<div class="stats-bar">
  <div>SCORE: <span id="score">0</span></div>
  <div>HIGH: <span id="hi">0</span></div>
  <div>LVL: <span id="level">1</span></div>
</div>

<div class="canvas-wrap">
  <canvas id="c" width="400" height="400"></canvas>
  <div class="overlay" id="overlay">
    <h2 id="overlay-title">SNAKE.EXE</h2>
    <p id="overlay-sub">USE ARROW KEYS OR WASD TO MOVE</p>
    <p>EAT THE FOOD. DON'T HIT THE WALLS.</p>
    <p>DON'T EAT YOURSELF.</p>
    <div class="start-hint blink">[ PRESS SPACE OR ENTER TO START ]</div>
  </div>
</div>

<div class="footer">↑↓←→ OR WASD &nbsp;|&nbsp; SPACE = PAUSE &nbsp;|&nbsp; ESC = RESTART</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const scoreEl = document.getElementById('score');
const hiEl = document.getElementById('hi');
const levelEl = document.getElementById('level');
const overlayTitle = document.getElementById('overlay-title');
const overlaySub = document.getElementById('overlay-sub');

const CELL = 20;
const COLS = canvas.width / CELL;
const ROWS = canvas.height / CELL;

let snake, dir, nextDir, food, score, hiScore, level, speed, gameLoop, state, particles;

hiScore = 0;

const GREEN = '#00ff41';
const MID = '#00aa2c';
const DIM = '#003b10';
const RED = '#ff3030';
const YELLOW = '#ffd700';

function init() {
  snake = [{x: 10, y: 10}, {x: 9, y: 10}, {x: 8, y: 10}];
  dir = {x: 1, y: 0};
  nextDir = {x: 1, y: 0};
  score = 0;
  level = 1;
  speed = 120;
  particles = [];
  updateUI();
  placeFood();
}

function placeFood() {
  let pos;
  do {
    pos = {x: Math.floor(Math.random() * COLS), y: Math.floor(Math.random() * ROWS)};
  } while (snake.some(s => s.x === pos.x && s.y === pos.y));
  food = pos;
  food.color = Math.random() > 0.8 ? YELLOW : GREEN;
  food.points = food.color === YELLOW ? 3 : 1;
}

function updateUI() {
  scoreEl.textContent = score;
  hiEl.textContent = hiScore;
  levelEl.textContent = level;
}

function spawnParticles(x, y, color) {
  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI * 2;
    particles.push({
      x: x * CELL + CELL / 2,
      y: y * CELL + CELL / 2,
      vx: Math.cos(angle) * (1 + Math.random() * 3),
      vy: Math.sin(angle) * (1 + Math.random() * 3),
      life: 1,
      color
    });
  }
}

function step() {
  dir = nextDir;
  const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

  // Wall collision
  if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) {
    endGame(); return;
  }

  // Self collision
  if (snake.some(s => s.x === head.x && s.y === head.y)) {
    endGame(); return;
  }

  snake.unshift(head);

  if (head.x === food.x && head.y === food.y) {
    const pts = food.points;
    spawnParticles(food.x, food.y, food.color);
    score += pts;
    if (score > hiScore) hiScore = score;
    level = Math.floor(score / 5) + 1;
    speed = Math.max(60, 120 - (level - 1) * 8);
    updateUI();
    placeFood();
    clearInterval(gameLoop);
    gameLoop = setInterval(step, speed);
  } else {
    snake.pop();
  }

  draw();
}

function draw() {
  // Background
  ctx.fillStyle = '#020d04';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Grid dots
  ctx.fillStyle = DIM;
  for (let x = 0; x < COLS; x++) {
    for (let y = 0; y < ROWS; y++) {
      ctx.fillRect(x * CELL + CELL / 2 - 0.5, y * CELL + CELL / 2 - 0.5, 1, 1);
    }
  }

  // Particles
  particles = particles.filter(p => p.life > 0);
  particles.forEach(p => {
    ctx.save();
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
    ctx.restore();
    p.x += p.vx;
    p.y += p.vy;
    p.life -= 0.06;
  });

  // Snake
  snake.forEach((seg, i) => {
    const isHead = i === 0;
    const alpha = isHead ? 1 : Math.max(0.3, 1 - i * 0.03);
    ctx.save();
    ctx.globalAlpha = alpha;
    
    if (isHead) {
      ctx.fillStyle = GREEN;
      ctx.shadowColor = GREEN;
      ctx.shadowBlur = 12;
    } else {
      ctx.fillStyle = i % 2 === 0 ? MID : '#009922';
      ctx.shadowColor = MID;
      ctx.shadowBlur = 4;
    }

    const pad = isHead ? 1 : 2;
    ctx.fillRect(seg.x * CELL + pad, seg.y * CELL + pad, CELL - pad * 2, CELL - pad * 2);
    
    // Head eyes
    if (isHead) {
      ctx.fillStyle = '#020d04';
      ctx.shadowBlur = 0;
      const ex = dir.x, ey = dir.y;
      const cx = seg.x * CELL + CELL / 2;
      const cy = seg.y * CELL + CELL / 2;
      const ox = ey !== 0 ? 4 : 0, oy = ex !== 0 ? 4 : 0;
      const fx = ex * 4, fy = ey * 4;
      ctx.fillRect(cx + fx + ox - 2, cy + fy + oy - 2, 3, 3);
      ctx.fillRect(cx + fx - ox - 2, cy + fy - oy - 2, 3, 3);
    }
    ctx.restore();
  });

  // Food
  const fx = food.x * CELL + CELL / 2;
  const fy = food.y * CELL + CELL / 2;
  const pulse = Math.sin(Date.now() / 200) * 2;
  ctx.save();
  ctx.fillStyle = food.color;
  ctx.shadowColor = food.color;
  ctx.shadowBlur = 15 + pulse;
  const r = 5 + pulse * 0.3;
  ctx.beginPath();
  ctx.arc(fx, fy, r, 0, Math.PI * 2);
  ctx.fill();
  if (food.points > 1) {
    ctx.fillStyle = '#020d04';
    ctx.shadowBlur = 0;
    ctx.font = 'bold 8px Share Tech Mono';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('★', fx, fy);
  }
  ctx.restore();
}

function endGame() {
  clearInterval(gameLoop);
  state = 'dead';
  overlayTitle.textContent = 'GAME OVER';
  overlaySub.textContent = `SCORE: ${score}  |  HIGH: ${hiScore}`;
  overlay.querySelector('.start-hint').textContent = '[ PRESS SPACE OR ENTER TO RESTART ]';
  overlay.style.display = 'flex';
}

function startGame() {
  init();
  overlay.style.display = 'none';
  state = 'playing';
  clearInterval(gameLoop);
  gameLoop = setInterval(step, speed);
}

function pauseGame() {
  if (state === 'playing') {
    clearInterval(gameLoop);
    state = 'paused';
    overlayTitle.textContent = 'PAUSED';
    overlaySub.textContent = '';
    overlay.querySelector('.start-hint').textContent = '[ PRESS SPACE TO CONTINUE ]';
    overlay.style.display = 'flex';
  } else if (state === 'paused') {
    overlay.style.display = 'none';
    state = 'playing';
    gameLoop = setInterval(step, speed);
  }
}

document.addEventListener('keydown', e => {
  if (e.key === ' ' || e.key === 'Enter') {
    if (state === 'start' || state === 'dead') startGame();
    else if (state === 'playing' || state === 'paused') pauseGame();
    e.preventDefault();
  }
  if (e.key === 'Escape') {
    clearInterval(gameLoop);
    state = 'start';
    overlayTitle.textContent = 'SNAKE.EXE';
    overlaySub.textContent = 'USE ARROW KEYS OR WASD TO MOVE';
    overlay.querySelector('.start-hint').textContent = '[ PRESS SPACE OR ENTER TO START ]';
    overlay.style.display = 'flex';
  }
  if (state !== 'playing') return;
  const dirs = {
    ArrowUp: {x:0,y:-1}, w: {x:0,y:-1},
    ArrowDown: {x:0,y:1}, s: {x:0,y:1},
    ArrowLeft: {x:-1,y:0}, a: {x:-1,y:0},
    ArrowRight: {x:1,y:0}, d: {x:1,y:0},
  };
  const nd = dirs[e.key];
  if (nd && !(nd.x === -dir.x && nd.y === -dir.y)) {
    nextDir = nd;
    e.preventDefault();
  }
});

// Touch support
let touchStart = null;
canvas.addEventListener('touchstart', e => { touchStart = e.touches[0]; e.preventDefault(); }, {passive:false});
canvas.addEventListener('touchend', e => {
  if (!touchStart) return;
  const dx = e.changedTouches[0].clientX - touchStart.clientX;
  const dy = e.changedTouches[0].clientY - touchStart.clientY;
  if (Math.abs(dx) < 10 && Math.abs(dy) < 10) {
    if (state === 'start' || state === 'dead') startGame();
    else pauseGame();
    return;
  }
  if (state !== 'playing') return;
  let nd;
  if (Math.abs(dx) > Math.abs(dy)) nd = dx > 0 ? {x:1,y:0} : {x:-1,y:0};
  else nd = dy > 0 ? {x:0,y:1} : {x:0,y:-1};
  if (!(nd.x === -dir.x && nd.y === -dir.y)) nextDir = nd;
  e.preventDefault();
}, {passive:false});

// Animate food pulse even when paused
function animLoop() {
  if (state !== 'playing') draw();
  requestAnimationFrame(animLoop);
}

state = 'start';
init();
draw();
animLoop();
</script>
</body>
</html>
